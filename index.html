<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>My Docs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Тема Docsify -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsify/themes/vue.css">
  <style>
    body { background: #fff; }
  </style>
</head>
<body>
  <div id="app">Загрузка...</div>
  <div id="search-box"></div>
  <script>
    // ===== Path utils =====

    // Каталог текущей страницы как URL- база (с хвостовым /)
    function pageBase() {
      return new URL('.', window.location.href);
    }

    // Первый сегмент пути (имя репозитория на GH Pages) либо ''
    function repoSegment() {
      const parts = window.location.pathname.split('/').filter(Boolean);
      return parts[0] || '';
    }

    // Удаляем ведущий base репозитория из href, если он там есть (и с /, и без)
    function stripRepoBase(href) {
      const repo = repoSegment();
      if (!repo) return href;
      return href
        .replace(new RegExp('^/' + repo + '/'), '')   // '/repo/guide' -> 'guide'
        .replace(new RegExp('^' + repo + '/'), '');   // 'repo/guide'  -> 'guide'
    }

    // Преобразуем относительный путь к абсолютному URL от каталога страницы
    function resolveFromPage(relative) {
      const clean = String(relative ?? '').trim().replace(/^\/+/, '');
      return new URL(clean, pageBase()).href;
    }

    // ===== Markdown/route utils =====

    // Нормализуем ссылки из _sidebar.md в относительные роуты Docsify:
    // '' (root), 'guide', 'dir/'
    function normalizeRoute(href) {
      if (!href) return null;

      // Убираем hash и query
      href = href.split('#')[0].split('?')[0].trim();

      // Внешние ссылки и mailto — пропускаем
      if (/^(https?:)?\/\//i.test(href) || /^mailto:/i.test(href)) return null;

      // Убираем ./ и двойные слэши
      href = href.replace(/^\.\//, '').replace(/\/{2,}/g, '/');

      // Сначала срежем базу репозитория, если автор в сайдбаре поставил абсолюты
      href = stripRepoBase(href);

      // Корневые варианты
      if (href === '' || href.toLowerCase() === 'readme.md' || href === '/') return '';

      // Каталог с завершающим слешем: 'dir/' → оставить
      if (/\/$/.test(href)) return href.replace(/^\//, '');

      // 'dir/README.md' → 'dir/'
      if (/\/readme\.md$/i.test(href)) return href.replace(/^\//, '').replace(/readme\.md$/i, '');

      // Если .md — срежем расширение
      if (/\.md$/i.test(href)) href = href.replace(/\.md$/i, '');

      // Вернём относительный роут без ведущего '/'
      return href.replace(/^\//, '');
    }

    // Преобразуем относительный роут к формату Docsify ('', 'guide', 'dir/') -> '/', '/guide', '/dir/'
    function toDocsifyRoute(route) {
      if (!route) return '/';
      return route.startsWith('/') ? route : '/' + route;
    }

    // Достаём href из markdown (исключаем картинки)
    function extractLinksFromMarkdown(mdText) {
      const links = [];
      const regex = /(?<!!)\[[^\]]*\]\(([^)]+)\)/g;
      let m;
      while ((m = regex.exec(mdText)) !== null) {
        const hrefRaw = m[1].trim();
        if (!hrefRaw || hrefRaw.startsWith('#')) continue;
        links.push(hrefRaw);
      }
      return links;
    }

    // Убираем дубликаты и пустые
    function dedupe(arr) {
      return Array.from(new Set(arr.filter(Boolean)));
    }

    // ===== Loaders =====

    // Загружаем _sidebar.md из каталога страницы (без удвоения /Danube_help)
    async function loadSidebar(url = '_sidebar.md') {
      const fullUrl = resolveFromPage(url);
      const res = await fetch(fullUrl, { cache: 'no-store', credentials: 'same-origin' });
      if (!res.ok) throw new Error('Не удалось загрузить ' + fullUrl + ' (HTTP ' + res.status + ')');
      return res.text();
    }

    // Собираем относительные роуты из сайдбара
    async function discoverRoutesFromSidebar() {
      const md = await loadSidebar();
      const hrefs = extractLinksFromMarkdown(md);

      const routes = hrefs
        .map(normalizeRoute)
        .filter((r) => r !== null);

      // Всегда добавляем корень
      routes.push('');

      // Возвращаем относительные роуты (НЕ абсолютные pathnames!)
      return dedupe(routes);
    }

    // Предзагружаем .md по относительным роутам
    async function preloadMarkdown(routes, opts = {}) {
      const docsDir = (opts.docsDir || '').replace(/^\/+|\/+$/g, ''); // 'docs' | ''

      const base = pageBase();                          // https://host/user/repo/
      const rootUrl = new URL(docsDir ? docsDir + '/' : '', base);

      const toFilePath = (route) => {
        let r = String(route || '').trim().replace(/^#?\/+/, ''); // делаем относительным
        if (!r) return 'README.md';
        if (r.endsWith('/')) return r + 'README.md';
        return r + '.md';
      };

      await Promise.all(routes.map(async (route) => {
        const file = toFilePath(route);
        const url = new URL(file, rootUrl).href;
        try {
          const res = await fetch(url, { cache: 'no-store', credentials: 'same-origin' });
          if (res.ok) await res.text();
        } catch (_) {
          // Тихо игнорируем сети/корс — цель: прогреть
        }
      }));
    }

    // ===== Bootstrap =====

    (async function bootstrapDocsify() {
      let routes = [];
      try {
        routes = await discoverRoutesFromSidebar();   // ['', 'guide', 'dir/']
        await preloadMarkdown(routes);
      } catch (_) {
        routes = ['']; // хотя бы корень
      }

      // Преобразуем для Docsify search.paths
      const docsifyPaths = routes.map(toDocsifyRoute); // ['/', '/guide', '/dir/']

      window.$docsify = {
        loadSidebar: true,                // подключать _sidebar.md для меню
        subMaxLevel: 2,
        search: {
          maxAge: 0,
          paths: docsifyPaths,
          depth: 6,
          hideOtherSidebarContent: false,
          placeholder: 'Поиск...',
          noData: 'Ничего не найдено',
          namespace: 'docs',
          element: '#search-box', 
          // Кастомная токенизация
          tokenize(text) {
            return text
              .toLowerCase()
              .replace(/[^a-zа-яё0-9\-]+/g, ' ')
              .split(/\s+/)
              .filter(Boolean);
          }
        }
      };

      // Динамически подключаем Docsify и плагин поиска
      const appendScript = (src) => new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = src;
        s.onload = resolve;
        s.onerror = reject;
        document.head.appendChild(s);
      });

      await appendScript('https://cdn.jsdelivr.net/npm/docsify/lib/docsify.min.js');
      await appendScript('https://cdn.jsdelivr.net/npm/docsify/lib/plugins/search.min.js');
    })();
  </script>
</body>
</html>