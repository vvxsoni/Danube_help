<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>My Docs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Подключение темы Docsify -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsify/themes/vue.css">
  <style>
    /* Небольшой UX: фоновый цвет до загрузки контента */
    body { background: #fff; }
  </style>
</head>
<body>
  <!-- Контейнер, в который Docsify отрендерит контент -->
  <div id="app">Загрузка...</div>
  <!-- Отдельный контейнер для поля поиска -->
  <div id="search-box"></div>

  <script>
    /**
     * pageBase — возвращает URL каталога текущей страницы (с хвостовым /).
     * Работает и локально, и на GitHub Pages.
     */
    function pageBase() {
      return new URL('.', window.location.href);
    }

    /**
     * repoSegment — находит первый сегмент пути (имя репозитория на GitHub Pages) или ''.
     * Например: /Danube_help/page -> "Danube_help".
     */
    function repoSegment() {
      const parts = window.location.pathname.split('/').filter(Boolean);
      return parts[0] || '';
    }

    /**
     * stripRepoBase — убирает имя репозитория из начала пути, если оно там есть.
     * Нужно, чтобы избежать удвоения /repo/repo/... в путях.
     */
    function stripRepoBase(href) {
      const repo = repoSegment();
      if (!repo) return href;
      return href
        .replace(new RegExp('^/' + repo + '/'), '')
        .replace(new RegExp('^' + repo + '/'), '');
    }

    /**
     * resolveFromPage — строит абсолютный URL для относительного пути,
     * отталкиваясь от каталога страницы (base path).
     */
    function resolveFromPage(relative) {
      const clean = String(relative ?? '').trim().replace(/^\/+/, '');
      return new URL(clean, pageBase()).href;
    }

    /**
     * normalizeRoute — нормализует ссылки из _sidebar.md в формат роутов Docsify:
     *   '' (root), 'guide', 'dir/'
     */
    function normalizeRoute(href) {
      if (!href) return null;
      // Отрезаем якорь и query
      href = href.split('#')[0].split('?')[0].trim();
      // Пропускаем внешние ссылки и mailto
      if (/^(https?:)?\/\//i.test(href) || /^mailto:/i.test(href)) return null;
      // Убираем ./ и повторяющиеся /
      href = href.replace(/^\.\//, '').replace(/\/{2,}/g, '/');
      // Срезаем базу репозитория, если есть
      href = stripRepoBase(href);
      // Корневые варианты
      if (href === '' || href.toLowerCase() === 'readme.md' || href === '/') return '';
      // 'dir/README.md' -> 'dir/'
      if (/\/readme\.md$/i.test(href))
        return href.replace(/^\//, '').replace(/readme\.md$/i, '');
      // Каталог с завершающим /
      if (/\/$/.test(href)) return href.replace(/^\//, '');
      // Убираем .md
      if (/\.md$/i.test(href)) href = href.replace(/\.md$/i, '');
      return href.replace(/^\//, '');
    }

    /**
     * extractLinksFromMarkdown — вытаскивает все ссылки [текст](ссылка) из markdown.
     * Игнорирует картинки ![alt](src) и якоря.
     */
    function extractLinksFromMarkdown(mdText) {
      const links = [];
      const regex = /(?<!!)\[[^\]]*\]\(([^)]+)\)/g;
      let m;
      while ((m = regex.exec(mdText)) !== null) {
        const hrefRaw = m[1].trim();
        if (!hrefRaw || hrefRaw.startsWith('#')) continue;
        links.push(hrefRaw);
      }
      return links;
    }

    /**
     * dedupe — удаляет дубликаты и пустые значения из массива.
     */
    function dedupe(arr) {
      return Array.from(new Set(arr.filter(Boolean)));
    }

    /**
     * loadSidebar — загружает _sidebar.md из текущего каталога сайта.
     * URL строится через resolveFromPage для избежания проблем с поддиректориями.
     */
    async function loadSidebar(url = '_sidebar.md') {
      const fullUrl = resolveFromPage(url);
      const res = await fetch(fullUrl, { cache: 'no-store', credentials: 'same-origin' });
      if (!res.ok) throw new Error(`Не удалось загрузить ${fullUrl} (HTTP ${res.status})`);
      return res.text();
    }

    /**
     * discoverRoutesFromSidebar — вытаскивает все относительные роуты из _sidebar.md.
     * Всегда добавляет '' (корневую страницу).
     */
    async function discoverRoutesFromSidebar() {
      const md = await loadSidebar();
      const hrefs = extractLinksFromMarkdown(md);
      const routes = hrefs.map(normalizeRoute).filter(r => r !== null);
      routes.push('');
      return dedupe(routes);
    }

    /**
     * preloadMarkdown — предзагружает Markdown-файлы для всех маршрутов,
     * чтобы поиск работал даже по ещё не открытым страницам.
     */
    async function preloadMarkdown(routes, opts = {}) {
      const docsDir = (opts.docsDir || '').replace(/^\/+|\/+$/g, ''); // например 'docs'
      const base = pageBase();
      const rootUrl = new URL(docsDir ? docsDir + '/' : '', base);

      const toFilePath = (route) => {
        let r = String(route || '').trim().replace(/^#?\/+/, '');
        if (!r) return 'README.md';
        if (r.endsWith('/')) return r + 'README.md';
        return r + '.md';
      };

      await Promise.all(routes.map(async (route) => {
        const file = toFilePath(route);
        const url = new URL(file, rootUrl).href;
        try {
          const res = await fetch(url, { cache: 'no-store', credentials: 'same-origin' });
          if (res.ok) await res.text();
        } catch (_) { /* Игнорируем ошибки сети/доступа */ }
      }));
    }

    /**
     * toDocsifyRoute — конвертирует относительный роут в формат, который ждёт Docsify:
     * '' -> '/', 'guide' -> '/guide'
     */
    function toDocsifyRoute(route) {
      if (!route) return '/';
      return route.startsWith('/') ? route : '/' + route;
    }

    /**
     * tokenize — мягкая токенизация для поиска:
     * поддерживает латиницу, кириллицу, цифры, дефисы.
     */
    function tokenize(text) {
      return text
        .toLowerCase()
        .replace(/[^a-zа-яё0-9\-]+/g, ' ')
        .split(/\s+/)
        .filter(Boolean);
    }

    /**
     * bootstrapDocsify — основной запуск:
     * - собирает маршруты
     * - предзагружает md
     * - настраивает Docsify
     * - подключает скрипты Docsify и поиска
     */
    (async function bootstrapDocsify() {
      let routes = [];
      try {
        routes = await discoverRoutesFromSidebar();
        await preloadMarkdown(routes);
      } catch (e) {
        routes = ['']; // фолбэк — только корень
      }

      const docsifyPaths = routes.map(toDocsifyRoute);
      if (!docsifyPaths.includes('/')) docsifyPaths.unshift('/');

      window.$docsify = {
        el: '#app',
        loadSidebar: true,
        subMaxLevel: 2,
        search: {
          maxAge: 0,
          paths: docsifyPaths,
          depth: 6,
          hideOtherSidebarContent: false,
          placeholder: 'Поиск...',
          noData: 'Ничего не найдено',
          namespace: 'docs',
          element: '#search-box', // поиск выводим в твой контейнер
          tokenize
        }
      };

      const appendScript = (src) => new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = src;
        s.onload = resolve;
        s.onerror = reject;
        document.head.appendChild(s);
      });

      await appendScript('https://cdn.jsdelivr.net/npm/docsify/lib/docsify.min.js');
      await appendScript('https://cdn.jsdelivr.net/npm/docsify/lib/plugins/search.min.js');
    })();
  </script>
</body>
</html>